type s []str

type p *u64

type ZeroCustom void

pub
type String struct {
    ptr: [*]u8
    len: u32
}

type Text struct {
    data: []u8
    path: str
    hash: u64
}

type Pool struct {
    m: map(str, *Text)
}

fun make_map(m: &map(str, uint)) -> (uint, bool) {
    var s: str = "hello";

    if m.num != 0 {
        ret m.num, true;
    }

    m.set(s, 1);
    a, ok := m.get(s);

    a = 10;
    a = #pin;
    
    if !m.has("abc") {
        ret 0, false;
    }
    
    ret a, ok; 
}

fun (&String) len0() -> u32 {
    ret 0;
}

#export
fun ret_tuple1() -> (uint) {
    var k: uint = 0;
    if k != 1 {

    } else if true {

    }

    for k != 0 {
        k = k + 1;
        if k > 10 {
            break;
        }
    }
    defer ret_tuple2();

    for 1 == 1 {
        ret 1;
    }

    for true {
        k = 2;
    }

    ret 0;
}

fun ret_tuple2() -> (uint, sint) {
    my_print(unit_var);
    ret 0, 1;
}

fun my_print(s: str) {}

const unit_var_init := "hello unit variable";

var unit_var: str = unit_var_init;

// #export
fun use_tuple() -> uint {
    var a: uint;
    a, b := ret_tuple2();
    if a == 0 {
        ret b;
    }
    ret a;
}

// type Variant union {
//     ptr: *void
//     num: uint
// }

#export
fun use_string(s: &String) {
    s.klen();
}

fun (&String) klen() -> u32 {
    must(true);

    var a: uint;
    must(a == 0);

    {
        a = 1;
    }
    if g.len0() == 1 {
        a = 2;
    }
    ret g.len + cast(u32, a);
}

const k := 10;

var kk: uint = a;

const a := 1 + 2;

const b := -0x1;

const c := 1 + (3 - 4);

const debug := true;

const a1 := a2;
const a2 := a1;

type Array struct {
    bots: []Bot
}

type Bot struct {
    name: str

    a: Array
}
