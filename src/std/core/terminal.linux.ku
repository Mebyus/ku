type LinuxTerminalProperties => struct {
    // various mode flags
    input:   u32,
    output:  u32,
    control: u32,
    local:   u32,
    
    // line discipline
    line: u8,
    
    // control characters
    cc: [32]u8,
}

fun fmt_cap_buffer_put_linux_terminal_properties(buf: *FormatCapBuffer, p: *LinuxTerminalProperties) {
    fmt_cap_buffer_put_str(buf, "local: ");
    fmt_cap_buffer_put_bin_bytes_u32(buf, p.*.local);
    fmt_cap_buffer_put_newline(buf);
}

/*
#[
    link.name = "tcgetattr";
    link.type = "external";
]
#stub
fun os_linux_get_terminal_properties(fd: sint, p: *LinuxTerminalProperties) => sint
*/

let OS_LINUX_TERMINAL_FILE_DESCRIPTOR => OS_LINUX_STDIN;

let OS_LINUX_TERMINAL_GET_PROPERTIES => 0x5401;

fun os_linux_get_terminal_properties(ptr: &LinuxTerminalProperties) => error_id {
    const n: sint = os_linux_amd64_syscall_ioctl(OS_LINUX_TERMINAL_FILE_DESCRIPTOR, OS_LINUX_TERMINAL_GET_PROPERTIES, ptr);
    if n < 0 {
        ret #error(TODO_IOCTL);
    }
    ret 0;
}

let OS_LINUX_TERMINAL_DRAIN_FLUSH_SET_PROPERTIES => 0x5404;

fun os_linux_set_terminal_properties(ptr: &LinuxTerminalProperties) => error_id {
    const n: sint = os_linux_amd64_syscall_ioctl(OS_LINUX_TERMINAL_FILE_DESCRIPTOR, OS_LINUX_TERMINAL_DRAIN_FLUSH_SET_PROPERTIES, ptr);
    if n < 0 {
        ret #error(TODO_IOCTL);
    }
    ret 0;
}

let OS_LINUX_TERMINAL_ECHO  => 0x08;
let OS_LINUX_TERMINAL_CANON => 0x02;
let OS_LINUX_TERMINAL_EXTEN => 0x8000;
let OS_LINUX_TERMINAL_SIG   => 0x01;

let OS_LINUX_TERMINAL_OUTPUT_PROCESSING => 0x01;
let OS_LINUX_TERMINAL_CHARACTER_SIZE_8  => 0x30;

let OS_LINUX_TERMINAL_BREAK_INTERRUPT => 0x02;
let OS_LINUX_TERMINAL_INPUT_PARITY    => 0x10;
let OS_LINUX_TERMINAL_STRIP_BIT       => 0x20;
let OS_LINUX_TERMINAL_TRANSLATE_CR    => 0x100;
let OS_LINUX_TERMINAL_X_FLOW_CONTROL  => 0x400;

let OS_LINUX_TERMINAL_WAIT_INPUT_TIMEOUT_SLOT => 5;
let OS_LINUX_TERMINAL_MIN_INPUT_SIZE_SLOT     => 6;

/*/doc
Save terminal state into a given pointer and then set terminal into raw mode.
*/
fun os_linux_enter_terminal_raw_mode(old: *LinuxTerminalProperties) => error_id {
    var eid: error_id = os_linux_get_terminal_properties(old);
    if eid != 0 {
        ret eid;
    }
    var properties: LinuxTerminalProperties = old.*;
    
    const input_mask: u32 = cast(u32, OS_LINUX_TERMINAL_BREAK_INTERRUPT) | cast(u32, OS_LINUX_TERMINAL_INPUT_PARITY) | cast(u32, OS_LINUX_TERMINAL_STRIP_BIT) | cast(u32, OS_LINUX_TERMINAL_TRANSLATE_CR) | cast(u32, OS_LINUX_TERMINAL_X_FLOW_CONTROL);
    properties.input &= ^input_mask;

    const output_mask: u32 = cast(u32, OS_LINUX_TERMINAL_OUTPUT_PROCESSING);
    properties.output &= ^output_mask;

    properties.control |= cast(u32, OS_LINUX_TERMINAL_CHARACTER_SIZE_8);

    const local_mask: u32 = cast(u32, OS_LINUX_TERMINAL_ECHO) | cast(u32, OS_LINUX_TERMINAL_CANON) | cast(u32, OS_LINUX_TERMINAL_EXTEN) | cast(u32, OS_LINUX_TERMINAL_SIG);
    properties.local &= ^local_mask;

    properties.cc[OS_LINUX_TERMINAL_WAIT_INPUT_TIMEOUT_SLOT] = 1;
    properties.cc[OS_LINUX_TERMINAL_MIN_INPUT_SIZE_SLOT] = 0;
    
    eid = os_linux_set_terminal_properties(properties.&);
    ret eid;
}

type TerminalColor => struct {
    red:   u8,
    green: u8,
    blue:  u8,
    flags: u8,
}

let TERMINAL_COLOR_RGB => 1;

fun terminal_color_pack_rgb(r: u8, g: u8, b: u8) => u32 {
    ret cast(u32, r) | (cast(u32, g) << 8) | (cast(u32, b) << 16) | (cast(u32, TERMINAL_COLOR_RGB) << 24);
}

type TerminalScreenCell => struct {
    text_color: u32,
    bg_color:   u32,

    rune: rune,
}

let TERMINAL_SCREEN_BUFFER_MAX_LINES => 256;

type TerminalScreenBuffer => struct {
    // For each line with index {i} contains {line_change_cutoff[i]} cutoff value
    // since last reset.
    //
    // Line change cutoff equals to number of cells in a line
    // from first cell to a changed cell with maximum index.
    //
    // Zero cutoff value means line was not changed since last reset.
    line_change_cutoff: [TERMINAL_SCREEN_BUFFER_MAX_LINES]u32,

    cells: [*]TerminalScreenCell,

    // Number of lines which contents were changed since last reset.
    line_change_num: u32,

    stride: u32,
    width:  u32,
    height: u32,

    cap: u32,
}

fun init_terminal_screen_buffer(screen: &TerminalScreenBuffer) {
    must(screen.*.height <= TERMINAL_SCREEN_BUFFER_MAX_LINES);

    screen.*.line_change_num = 0;

    clear(make_span_u8(cast([*]u8, screen.*.line_change_cutoff), TERMINAL_SCREEN_BUFFER_MAX_LINES * #size(u32)));
    clear(make_span_u8(cast([*]u8, screen.*.cells), screen.*.cap * #size(TerminalScreenCell)));
}

fun terminal_screen_buffer_set_cell(screen: &TerminalScreenBuffer, x: u32, y: u32, cell: &TerminalScreenCell) {
    const i: uint = y * screen.*.stride + x;
    screen.*.cells.[i] = cell.*;
}

type TerminalOutputBuffer => struct {
    ptr: [*]u8,
    len: uint,
    cap: uint,

    // Current text color in use.
    text_color: u32,

    // Current background color in use.
    bg_color: u32,
}

fun init_terminal_output_buffer(out: &TerminalOutputBuffer, buf: []u8) {
    out.*.ptr = buf.ptr;
    out.*.len = 0;
    out.*.cap = buf.len;
}

/*/doc
Reserve memory inside buffer for at least {n} consecutive bytes to be written.
Does nothing if buffer already has enough memory.
*/
fun terminal_output_buffer_reserve(out: &TerminalOutputBuffer, n: uint) => error_id {
    const left: uint = out.*.cap - out.*.len;
    if n <= left {
        ret 0;
    }

    // TODO: allocate new memory
    ret 0;
}

fun terminal_output_buffer_take(out: &TerminalOutputBuffer) => []u8 {
    const s: []u8 = make_span_u8(out.*.ptr, out.*.len);
    out.*.len = 0;
    ret s;
}

fun terminal_output_buffer_put_byte(out: &TerminalOutputBuffer, x: u8) {
    terminal_output_buffer_reserve(out, 1);
    out.*.ptr.[out.*.len] = x;
    out.*.len += 1;
}

fun terminal_output_buffer_put_newline(out: &TerminalOutputBuffer) {
    terminal_output_buffer_reserve(out, 2);
    out.*.ptr.[out.*.len] = '\r';
    out.*.ptr.[out.*.len + 1] = '\n';
    out.*.len += 2;
}

fun terminal_output_buffer_put_rune(out: &TerminalOutputBuffer, r: rune) {
    terminal_output_buffer_reserve(out, 4);
    const n: uint = unsafe_utf8_encode_rune(out.*.ptr + out.*.len, r);
    out.*.len += n;
}

fun terminal_output_buffer_put_str(out: &TerminalOutputBuffer, s: str) {
    if s.len == 0 {
        ret;
    }

    terminal_output_buffer_reserve(out, s.len);
    unsafe_copy(out.*.ptr + out.*.len, s.ptr, s.len);
    out.*.len += s.len;
}

fun terminal_output_buffer_put_escape(out: &TerminalOutputBuffer) {
    terminal_output_buffer_reserve(out, 2);
    out.*.ptr.[out.*.len] = 0x1B;
    out.*.ptr.[out.*.len + 1] = '[';
    out.*.len += 2;
}

fun terminal_output_buffer_add_command_clear_screen(out: &TerminalOutputBuffer) {
    terminal_output_buffer_put_escape(out);
    terminal_output_buffer_put_str(out, "2J");
}

fun terminal_output_buffer_add_command_clear_styles(out: &TerminalOutputBuffer) {
    terminal_output_buffer_put_escape(out);
    terminal_output_buffer_put_str(out, "0m");
}

fun terminal_output_buffer_put_dec_u8(out: &TerminalOutputBuffer, x: u8) {
    terminal_output_buffer_reserve(out, 3);
    const n: uint = unsafe_fmt_dec_u64(out.*.ptr + out.*.len, x);
    out.*.len += n;
}

fun terminal_output_buffer_put_dec_u32(out: &TerminalOutputBuffer, x: u32) {
    terminal_output_buffer_reserve(out, 10);
    const n: uint = unsafe_fmt_dec_u64(out.*.ptr + out.*.len, x);
    out.*.len += n;
}

fun terminal_output_buffer_put_rgb(out: &TerminalOutputBuffer, r: u8, g: u8, b: u8) {
    terminal_output_buffer_reserve(out, 3 + 1 + 3 + 1 + 3);

    terminal_output_buffer_put_dec_u8(out, r);
    terminal_output_buffer_put_byte(out, ';');
    terminal_output_buffer_put_dec_u8(out, g);
    terminal_output_buffer_put_byte(out, ';');
    terminal_output_buffer_put_dec_u8(out, b);
}

fun terminal_output_buffer_add_command_set_text_color(out: &TerminalOutputBuffer, c: u32) {
    const kind: u32 = c >> 24;

    if kind
    => 0 {
        terminal_output_buffer_put_escape(out);
        terminal_output_buffer_put_str(out, "39m");
    }
    => TERMINAL_COLOR_RGB {
        const red: u8 = cast(u8, c & 0xFF);
        const green: u8 = cast(u8, (c >> 8) & 0xFF);
        const blue: u8 = cast(u8, (c >> 16) & 0xFF);

        terminal_output_buffer_put_escape(out);
        terminal_output_buffer_put_str(out, "38;2;");
        terminal_output_buffer_put_rgb(out, red, green, blue);
        terminal_output_buffer_put_byte(out, 'm');
    }
    else { #never; }
}

fun terminal_output_buffer_switch_color(out: &TerminalOutputBuffer, text: u32, bg: u32) {
    if text != out.*.text_color {
        terminal_output_buffer_add_command_set_text_color(out, text);
        out.*.text_color = text;
    }
    if bg != out.*.bg_color {
        // TODO: add command for switching background color
        out.*.bg_color = bg;
    }
}

fun terminal_output_buffer_enable_alt_screen(out: &TerminalOutputBuffer) {
    terminal_output_buffer_put_escape(out);
    terminal_output_buffer_put_str(out, "?1049h");
}

fun terminal_output_buffer_disable_alt_screen(out: &TerminalOutputBuffer) {
    terminal_output_buffer_put_escape(out);
    terminal_output_buffer_put_str(out, "?1049l");
}

fun terminal_output_buffer_show_cursor(out: &TerminalOutputBuffer) {
    terminal_output_buffer_put_escape(out);
    terminal_output_buffer_put_str(out, "?25h");
}

fun terminal_output_buffer_hide_cursor(out: &TerminalOutputBuffer) {
    terminal_output_buffer_put_escape(out);
    terminal_output_buffer_put_str(out, "?25l");
}

/*/doc
Move cursor to position (x, y) on the screen. Coordinates are zero-based.
*/
fun terminal_output_buffer_move_cursor(out: &TerminalOutputBuffer, x: u32, y: u32) {
    terminal_output_buffer_put_escape(out);
    terminal_output_buffer_put_dec_u32(out, x + 1);
    terminal_output_buffer_put_byte(out, ';');
    terminal_output_buffer_put_dec_u32(out, y + 1);
    terminal_output_buffer_put_byte(out, 'H');
}

fun render_terminal_screen_buffer(out: &TerminalOutputBuffer, screen: &TerminalScreenBuffer) {
    terminal_output_buffer_add_command_clear_screen(out);

    var y: u32 = 0; // line index
    var offset: u32 = 0; 
    for y < screen.*.height {
        var x: u32 = 0; // column index
        for x < screen.*.width {
            const i: u32 = offset + x;
            const cell: TerminalScreenCell = screen.*.cells.[i];

            terminal_output_buffer_switch_color(out, cell.text_color, cell.bg_color);
            
            if cell.rune != 0 {
                terminal_output_buffer_put_rune(out, cell.rune);
            } else {
                terminal_output_buffer_put_byte(out, ' ');
            }

            x += 1;
        }

        y += 1;
        if y >= screen.*.height {
            jump @.out;
        }

        offset += screen.*.stride;
        terminal_output_buffer_put_newline(out);
    }

    terminal_output_buffer_add_command_clear_styles(out);
}

type TerminalViewportInfo => struct {
    rows: u16,
    cols: u16,

    x_pixel: u16,
    y_pixel: u16,
}

let OS_LINUX_TERMINAL_GET_VIEWPORT_INFO => 0x5413;

fun os_linux_get_terminal_viewport_info(ptr: *TerminalViewportInfo) => error_id {
    const n: sint = os_linux_amd64_syscall_ioctl(OS_LINUX_TERMINAL_FILE_DESCRIPTOR, OS_LINUX_TERMINAL_GET_VIEWPORT_INFO, ptr);
    if n < 0 {
        ret #error(TODO_IOCTL);
    }
    ret 0;
}
