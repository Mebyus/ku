

/*/doc
Puts decimal digits of a number in reverse order inside a buffer.
Returns number of digits written.

Array must have enough space to hold produced bytes.

To clarify: last (least significant) digit is placed at {p.[0]}.

This operation is safe if buffer is at least {max_u64_fmt_dec_length} (=20) bytes long.
*/
fun unsafe_fmt_reverse_dec_u64(p: [&]u8, x: u64) => uint {
	var i: uint = 0;
	for {
		const n: u8 = tint(u8, x % 10);
		x /= 10;
		p.[i] = fmt_dec_digit(n);
		i += 1;
		if x == 0 {
			ret i;
		}
	}
}

/*/doc
Maximum number of bytes (digits) needed to format any u64 integer as decimal number.
*/
const max_u64_fmt_dec_length: uint = 20;

/*/doc
Same as fmt_dec_u64, but has no buffer boundary checks.
*/
fun unsafe_fmt_dec_u64(p: [&]u8, x: u64) => uint {
	var digits: [max_u64_fmt_dec_length]u8 = ?;
	const n: uint = unsafe_fmt_reverse_dec_u64(digits, x);
	unsafe_reverse_copy(p, digits, n);
	ret n;
}

fun unsafe_fmt_reverse_dec_fixed_width_u64(p: [&]u8, x: u64, w: uint) {
	var i: uint = 0;
	for i < w {
		const n: u8 = cast(u8, x % 10);
		x /= 10;
		p.[i] = fmt_dec_digit(n);
		i += 1;
	}
}

/*/doc
Formats integer as decimal number with fixed number of digits.
If number does not have enough digits to fill the whole width than
zeroes are prefixed. If number has more digits then specified width
than only least significant ones will be written.
*/
fun unsafe_fmt_dec_fixed_width_u64(p: [&]u8, x: u64, w: uint) {
	var digits: [max_u64_fmt_dec_length]u8 = ?;
	unsafe_fmt_reverse_dec_fixed_width_u64(digits, x, w);
	unsafe_reverse_copy(p, digits, w);
}

/*/doc
Puts integer {x} into a given buffer as text in decimal format.

Returns number of bytes written. Returns 0 if buffer does not
have enough bytes for the operation.
*/
fun fmt_dec_u64(buf: []u8, x: u64) => uint {
	if buf.len == 0 {
		ret 0;
	}
	must(buf.ptr != nil);
	
	if buf.len >= max_u64_fmt_dec_length {
		ret unsafe_fmt_dec_u64(buf.ptr, x);
	}
	
	var digits: [max_u64_fmt_dec_length]u8 = ?;
	const n: uint = unsafe_fmt_reverse_dec_u64(digits, x);
	if (n > buf.len) {
		// Not enough space in buffer to represent integer.
		ret 0;
	}

	unsafe_reverse_copy(buf.ptr, digits, n);
	ret n;
}

const fmt_bits_f32_length: uint = 32 + 2;

/*/doc
IEEE 754 32-bit float
*/
fun unsafe_fmt_bits_f32(p: [&]u8, f: f32) {
    const bits: u32 = get_bits_f32(f);

    // format fraction digits
    for i = [:23] {
        p.[33 - i] = fmt_dec_digit(cast(u8, (bits >> i) & 1));
    }

    // format exponent digits
    p.[10] = ' ';
    for i = [23:31] {
        p.[32 - i] = fmt_dec_digit(cast(u8, (bits >> i) & 1));
    }

    // format sign bit
    p.[1] = ' ';
    p.[0] = fmt_dec_digit(cast(u8, (bits >> 31) & 1));
}

/*/doc
Maximum number of bytes (digits) needed to format any u64 integer as decimal number.
*/
const max_s64_fmt_dec_length: uint = max_u64_fmt_dec_length + 1;

fun unsafe_fmt_dec_s64(p: [&]u8, x: s64) => uint {
	if x >= 0 {
		ret unsafe_fmt_dec_u64(p, cast(u64, x));
	}

	p.[0] = '-';
	const n: uint = unsafe_fmt_dec_u64(p + 1, cast(u64, -x));
	ret n + 1;
}


const max_time_dur_fmt_micro_length: uint = max_s64_fmt_dec_length + 1 + 6;

/*/doc
Formats time duration like this: 17.053793 (with microsecond precision).
Returns number of bytes actually written.
*/
fun unsafe_fmt_time_dur_micro(p: [&]u8, t: TimeDur) => uint {
	// TODO: maybe we should support negative durations as well
	var n: uint = unsafe_fmt_dec_u64(p, cast(u64, t.sec));
	
	p.[n] = '.';
	n += 1;
	
	unsafe_fmt_dec_fixed_width_u64(p + n, cast(u64, t.nsec) / 1000, 6);
	ret n + 6;
}

type FormatBuffer => struct {
    // Memory allocated by this buffer from {al}.
    block: MemoryBlock,

    // Additional memory for buffer can be requested from this allocator.
    // Can be nil in case buffer operates on a fixed preallocated span.
    al: MemoryAllocator,

	// Pointer to buffer memory.
	// Always not nil for initialized struct.
	ptr: [*]u8,

	// Content length. How many bytes is already written to buffer.
	// Length cannot be greater than capacity.
	len: uint,

	// Buffer storage capacity. Max bytes it can hold.
	cap: uint,

    // Indicates that buffer is full and cannot be expanded via allocations.
    eof: bool,
}

fun fmt_buffer_reset(buf: *FormatBuffer) {
	buf.*.len = 0;
    buf.*.eof = false;
}

fun init_fmt_buffer(buf: *FormatBuffer, s: []u8, al: MemoryAllocator) {
    const min_buffer_initial_size: uint = 1 << 8;

	must(s.len >= min_buffer_initial_size);
	must(s.ptr != nil);

    memory_block_clear_fields(buf.*.block.&);
    buf.*.al = al;
	buf.*.ptr = s.ptr;
	buf.*.cap = s.len;
    fmt_buffer_reset(buf);
}

/*

fun free_fmt_buffer(buf: *FormatBuffer) {
    if buf.*.al.kind == 0 {
        ret;
    }
    if buf.*.block.span.ptr == nil {
        ret;
    }

    memory_free(buf.*.al, buf.*.block.&);
}

*/
