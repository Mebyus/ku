import std {
    core -> "core"
}

/*/doc
Structure for bookkeeping allocated strings data inside the pool.
*/
type StringPoolBucket => struct {
    block: MemoryBlock,

    // Total number of bytes allocated by strings in this bucket.
    num: u32,
}

type StringPoolSlot => struct {
    val: str,
    
    // Link counter of the string
    links: u32,

    // Bucket id where string data is stored.
    // Zero value means that this string data is not stored in pool.
    //
    // {bucket} = {bucket_index} + 1
    bucket: u32,
}

let STRING_POOL_BUCKETS_NUMBER => 8;

let STRING_POOL_REUSE_STACK_SIZE => 256;

type StringPool => struct {
    buckets: [STRING_POOL_BUCKETS_NUMBER]StringPoolBucket,

    // Contains slot indices which can be reused when adding new strings to pool.
    reuse_stack: [STRING_POOL_REUSE_STACK_SIZE]u32,

    // Maps strings to their indices inside {slots} span.
    map: MapStrU64,

    // Allocated memory block which stores {slots} data.
    block: MemoryBlock,

    al: MemoryAllocator,

    slots: [*]StringPoolSlot,

    // Number of occupied slots.
    num: u32,

    // Slots capacity.
    cap: u32,

    // Reuse stack position (index) for inserting new element.
    // Also equal to number of elements inside the stack.
    pos: u32,

    // Total number of bytes allocated by strings in all buckets.
    total: u32,

    // Total number of wasted bytes in all buckets.
    //
    // Equals to sum of all allocated string sizes with 0 links.
    wasted: u32,
}

let STRING_POOL_BUCKET_SIZE => 1 << 24;

fun init_str_pool(p: &StringPool, al: MemoryAllocator, cap: u32) => error_id {
    p.*.block.span.len = cap * #size(StringPoolSlot);
    var eid: error_id = memory_alloc(al, p.*.block.&);
    if eid != 0 {
        ret eid;
    }

    p.*.slots = cast([*]StringPoolSlot, p.*.block.span.ptr);
    p.*.cap = cast(u32, p.*.block.span.len / #size(StringPoolSlot));

    eid = init_map_str_u64(p.*.map.&, al, p.*.cap);
    if eid != 0 {
        ret eid;
    }

    p.*.al = al;
    p.*.num = 0;
    p.*.pos = 0;

    p.*.total = 0;
    p.*.wasted = 0;

    ret 0;
}

type RetPoolSlot => struct {
    eid: error_id,

    // Slot {id} = {slot_index} + 1.
    //
    // Zero id means empty string.
    slot_id: u32,
}

fun fmt_cap_buffer_put_str_pool_slot(buf: &FormatCapBuffer, s: &StringPoolSlot) {
    fmt_cap_buffer_put_str(buf, "\"");
    fmt_cap_buffer_put_str(buf, s.*.val);
    fmt_cap_buffer_put_str(buf, "\" (");
    fmt_cap_buffer_put_dec_u64(buf, s.*.links);
    fmt_cap_buffer_put_str(buf, ", ");
    fmt_cap_buffer_put_dec_u64(buf, s.*.bucket);
    fmt_cap_buffer_put_str(buf, ")");
}

fun str_pool_print_slots(p: &StringPool) {
    var output_buffer: [1 << 16]u8 = ?;
    var buf: FormatCapBuffer = ?;
    init_fmt_cap_buffer(buf.&, make_span_u8(output_buffer, output_buffer.len));

    fmt_cap_buffer_put_str(buf.&, "pool(num, cap) = (");
    fmt_cap_buffer_put_dec_u64(buf.&, p.*.num);
    fmt_cap_buffer_put_str(buf.&, ", ");
    fmt_cap_buffer_put_dec_u64(buf.&, p.*.cap);
    fmt_cap_buffer_put_str(buf.&, ")");
    fmt_cap_buffer_put_newline(buf.&);

    for i = [:p.*.num] {
        var s: StringPoolSlot = p.*.slots.[i];
        fmt_cap_buffer_put_dec_u64(buf.&, i);
        fmt_cap_buffer_put_str(buf.&, ": ");
        fmt_cap_buffer_put_str_pool_slot(buf.&, s.&);
        fmt_cap_buffer_put_newline(buf.&);
    }

    stdout_print(fmt_cap_buffer_take(buf.&));
}

fun str_pool_calc_grow_cap(len: u32) => u32 {
    if len < 8 {
        ret 16;
    }
    if len < (1 << 16) {
        ret len << 1;
    }

    ret len + (len >> 2);
}

fun str_pool_slots_grow(p: &StringPool) => error_id {
    if p.*.al.ptr == 0 {
        ret #error(NIL_MEMORY_ALLOCATOR);
    }

    var cap: u32 = str_pool_calc_grow_cap(p.*.cap);
    var block: MemoryBlock = ?;
    block.span.len = cap * #size(StringPoolSlot);
    const eid: error_id = memory_alloc(p.*.al, block.&); // TODO: use realloc?
    if eid != 0 {
        ret eid;
    }

    var slots: [*]StringPoolSlot = cast([*]StringPoolSlot, block.span.ptr);
    cap = cast(u32, block.span.len / #size(StringPoolSlot));
    if p.*.num != 0 {
        unsafe_copy(cast([&]u8, slots), cast([&]u8, p.*.slots), p.*.num * #size(StringPoolSlot));
    }

    p.*.slots = slots;
    p.*.cap = cap;
    
    if p.*.block.span.len != 0 {
        memory_free(p.*.al, p.*.block.&);
    }
    p.*.block = block;
    ret 0;
}

/*/doc
Perform garbage collection of allocated strings.
*/
fun str_pool_gc(p: &StringPool) {
    var i: u32 = p.*.num;
    for i != 0 && p.*.pos < STRING_POOL_REUSE_STACK_SIZE {
        i -= 1;
        
        const slot: StringPoolSlot = p.*.slots.[i];
        if slot.links == 0 {
            if slot.bucket != 0 {
                // TODO: need to reorganize buckets
            }

            map_str_u64_del(p.*.map.&, slot.val);
            p.*.reuse_stack[p.*.pos] = i;
            p.*.pos += 1;
        }
    }
}

/*/doc
Adds (via possible copy) a given string to pool. There are two cases for this operation:
1. Pool does not contain a string identical to a given one.
2. Pool contains a string identical to a given one.

In case 1 string is not copied. Function returns id of already stored string and
increases its link count by 1.

In case 2 string is copied and stored inside the pool. Function returns id
of the new string with its link count set to 1.
*/
fun str_pool_add_copy(p: &StringPool, s: str) => RetPoolSlot {
    var ps: RetPoolSlot;
    if s.len == 0 {
        ret ps;
    }
    if s.len > STRING_POOL_BUCKET_SIZE {
        ps.eid = #error(LONG_STRING);
        ret ps;
    }

    const r: RetU64 = map_str_u64_get(p.*.map.&, s);
    if r.ok {
        ps.slot_id = cast(u32, r.val + 1);
        ret ps;
    }

    #stub;
    ret ps;
}

/*/doc
Adds a given string to pool. This operation never copies the string.
It may only store its shallow reference. May return id of already stored string.
*/
fun str_pool_add(p: &StringPool, s: str) => RetPoolSlot {
    var ps: RetPoolSlot;
    if s.len == 0 {
        ret ps;
    }
    const r: RetU64 = map_str_u64_get(p.*.map.&, s);
    if r.ok {
        const i: u32 = cast(u32, r.val);
        // TODO: replace allocated string if possible
        p.*.slots[i].links += 1;
        ps.slot_id = i + 1;
        ret ps;
    }

    var i: u32; // slot index where string header will be stored
    if p.*.pos != 0 {
        p.*.pos -= 1;
        i = p.*.reuse_stack.[p.*.pos];
    } else { 
        if p.*.num >= p.*.cap {
            const eid: error_id = str_pool_slots_grow(p);
            if eid != 0 {
                ps.eid = eid;
                ret ps;
            }
        }
        i = p.*.num;
        p.*.num += 1;
    }

    const eid: error_id = map_str_u64_set(p.*.map.&, s, i);
    if eid != 0 {
        ps.eid = eid;
        ret ps;
    }

    const slot: StringPoolSlot = {
        val:    s,
        links:  1,
        bucket: 0,
    };
    p.*.slots.[i] = slot;
    ps.slot_id = i + 1;
    ret ps;
}

/*/doc
Removes one link from stored string. Panics if string is not found or its link
count is already 0.

When link count of stored string reaches 0, it becomes subject to pool-internal
garbage collection.
*/
fun str_pool_unlink(p: &StringPool, id: u32) {
    if id == 0 {
        ret;
    }

    // slot index
    const i: u32 = id - 1; 
    must(i < p.*.num);
    
    const slot: StringPoolSlot = p.*.slots.[i];
    must(slot.links != 0);

    if slot.bucket != 0 && slot.links == 1 {
        p.*.wasted += cast(u32, slot.val.len);
    }

    p.*.slots.[i].links -= 1;
}

fun str_pool_get(p: &StringPool, id: u32) => str {
    if id == 0 {
        ret "";
    }

    // slot index
    const i: u32 = id - 1; 
    must(i < p.*.num);
    
    const slot: StringPoolSlot = p.*.slots.[i];
    must(slot.links != 0);

    ret slot.val;
}

fun str_pool_free(p: &StringPool) {
    for i = [:STRING_POOL_BUCKETS_NUMBER] {
        if p.*.buckets.[i].block.span.len != 0 {
            memory_free(p.*.al, p.*.buckets.[i].block.&);    
        }
    }
    if p.*.block.span.len != 0 {
        memory_free(p.*.al, p.*.block.&);
    }
    map_str_u64_free(p.*.map.&);
}


type StringPoolView => struct {

}

fun str_pool_add_lines_from_text(p: &StringPool, view: &StringPoolView, text: str) {

}
